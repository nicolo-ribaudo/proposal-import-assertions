<!doctype html>
<meta charset="utf8">
<script src="ecmarkup.js"></script>
<link rel="stylesheet" href="ecmarkup.css">
<title>Import Attributes</title>
<pre class=metadata>
  title: Import attributes
  status: proposal
  stage: 3
  location: https://github.com/tc39/proposal-import-assertions
  copyright: false
  contributors: Sven Sauleau, Myles Borins, Daniel Ehrenberg, Daniel Clark
</pre>
<emu-intro id="intro">
  <h1>Import Attributes</h1>
  <p>Import Attributes are an extension to the import syntax that allows specifying additional information to affect how the module is imported. This proposal, other than defining such syntax, also defines the first import attribtue: `type`, which is passed to the host to specify the expected type of the loaded module. See <a href="https://github.com/tc39/proposal-import-assertions/blob/master/README.md">the explainer</a> for more information.</p>
  <p>
    Possible future extensions include:
    <ul>
      <li>a `module` attribute, to import an object representing the dependency's Module Record instead of evaluating it;</li>
      <li>a `defer` attribute, to import a module without evaluating it immediately.</li>
    </ul>
  </p>
  <p>Not every import attribute needs to interact with host semantics, for example `module` and `defer` could be defined completely within ECMA-262.</p>
</emu-intro>

<emu-clause id="sec-syntax">
  <h1>Syntax</h1>

  <emu-grammar>
    ImportDeclaration :
      `import` ImportClause FromClause `;`
      `import` ModuleSpecifier `;`
      <ins>`import` ImportClause FromClause [no LineTerminator here] AttributesClause `;`</ins>
      <ins>`import` ModuleSpecifier [no LineTerminator here] AttributesClause `;`</ins>

    ExportDeclaration :
      `export` ExportFromClause FromClause `;`
      <ins>`export` ExportFromClause FromClause [no LineTerminator here] AttributesClause `;`</ins>
      `export` NamedExports `;`
      `export` VariableStatement[~Yield, ~Await]
      `export` Declaration[~Yield, ~Await]
      `export` `default` HoistableDeclaration[~Yield, ~Await, +Default]
      `export` `default` ClassDeclaration[~Yield, ~Await, +Default]
      `export` `default` [lookahead &lt;! {`function`, `async` [no |LineTerminator| here] `function`, `class`}] AssignmentExpression[+In, ~Yield, ~Await] `;`

    AttributesClause :
      <ins>`with` `{` `}`</ins>
      <ins>`with` `{` AttributeEntries `,`? `}`</ins>

    AttributeEntries :
      <ins>AttributeEntry</ins>
      <ins>AttributeEntries `,` AttributeEntry</ins>

    AttributeEntry :
      <ins>AttributeKey `:` StringLiteral</ins>

    AttributeKey:
      <ins>IdentifierName</ins>
      <ins>StringLiteral</ins>

    ImportCall[Yield, Await] :
      `import` `(` AssignmentExpression[+In, ?Yield, ?Await] <ins>`,`?</ins> `)`
      <ins>`import` `(` AssignmentExpression[+In, ?Yield, ?Await] `,` AssignmentExpression[+In, ?Yield, ?Await] `,`? `)`</ins>
  </emu-grammar>
</emu-clause>

<emu-clause id="sec-semantics">
  <h1>Semantics</h1>

  <emu-note type="editor"><p>Many productions operating on grammar are the same whether or not an |AttributesClause|/second |ImportCall| parameter is included; the new parameter is ignored. In this section, only the semantically significant changes are included, and the PR to merge into the main specification would fill in the straightforward details.</p></emu-note>

    <emu-clause id="sec-import-calls">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-clause id="sec-evaluate-import-call">
          <h1>EvaluateImportCall ( _specifierExpression_ [ , _optionsExpression_ ] )</h1>
          <emu-alg>
            1. Let _referencingScriptOrModule_ be ! GetActiveScriptOrModule().
            1. Let _specifierRef_ be the result of evaluating _specifierExpression_.
            1. Let _specifier_ be ? GetValue(_specifierRef_).
            1. If _optionsExpression_ is present, then
              1. Let _optionsRef_ be the result of evaluating _optionsExpression_.
              1. Let _options_ be ? GetValue(_optionsRef_).
            1. Else,
              1. Let _options_ be *undefined*.
            1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
            1. Let _specifierString_ be ToString(_specifier_).
            1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
            1. Let _moduleRequest_ be a new ModuleRequest Record { [[Specifier]]: _specifierString_, [[Type]]: ~empty~ }.
            1. If _options_ is not *undefined*, then
              1. If Type(_options_) is not Object,
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                1. Return _promiseCapability_.[[Promise]].
              1. Let _attributesObj_ be Get(_options_, *"with"*).
              1. IfAbruptRejectPromise(_attributesObj_, _promiseCapability_).
              1. If _attributesObj_ is not *undefined*,
                1. If Type(_attributesObj_) is not Object,
                  1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                  1. Return _promiseCapability_.[[Promise]].
                1. Let _keys_ be EnumerableOwnPropertyNames(_attributesObj_, ~key~).
                1. IfAbruptRejectPromise(_keys_, _promiseCapability_).
                1. For each String _key_ of _keys_,
                  1. Let _value_ be Get(_attributesObj_, _key_).
                  1. IfAbruptRejectPromise(_value_, _promiseCapability_).
                  1. If Type(_value_) is not String, then
                    1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; a newly created *TypeError* object &raquo;).
                    1. Return _promiseCapability_.[[Promise]].
                  1. If _key_ is *"type"*, then
                    1. Assert: _moduleRequest_.[[Type]] is ~empty~.
                    1. Set _moduleRequest_.[[Type]] to _value_.
                  1. TODO: Throw on unknown keys?
            1. Perform HostLoadImportedModule(_referrer_, _moduleRequest_, ~empty~, _promiseCapability_).
            1. Return _promiseCapability_.[[Promise]].
          </emu-alg>
        </emu-clause>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `,`? `)`</emu-grammar>
        <emu-alg>
          1. Return ? EvaluateImportCall(|AssignmentExpression|).
        </emu-alg>

        <ins><emu-grammar>ImportCall : `import` `(` AssignmentExpression `,` AssignmentExpression `,`? `)`</emu-grammar></ins>
        <emu-alg>
          1. Return ? EvaluateImportCall(the first |AssignmentExpression|, the second |AssignmentExpression|).
        </emu-alg>
      </emu-clause>
    </emu-clause>

      <emu-clause id="sec-hostloadimportedmodule" aoid="HostLoadImportedModule">
        <h1>HostLoadImportedModule ( _referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _hostDefined_, _payload_ )</h1>
        <p>The host-defined abstract operation HostLoadImportedModule takes arguments _referrer_ (a Script Record, a Cyclic Module Record, or a Realm Record), <del>_specifier_ (a String)</del><ins>_moduleRequest_ (a ModuleRequest Record)</ins>, _hostDefined_ (anything), and _payload_ (a GraphLoadingState Record or a PromiseCapability Record) and returns ~unused~.</p>

        <emu-note>
          <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            <p>If this operation is called multiple times with the same <del>(_referrer_, _specifier_) pair</del><ins>(_referrer_, _moduleRequest_.[[Specifier]], _moduleRequest_.[[Type]]) triple</ins> and it performs FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadingImportedModule(_referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_) with the same _result_ each time.</p>
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadingImportedModule.
          </li>
        </ul>
      </emu-clause>

      <emu-clause id="sec-FinishLoadingImportedModule" type="abstract operation">
        <h1>FinishLoadingImportedModule ( _referrer_, <del>_specifier_</del><ins>_moduleRequest_</ins>, _payload_, _result_ )</h1>
        <p>The abstract operation FinishLoadingImportedModule takes arguments _referrer_ (a Script Record, a Cyclic Module Record, or a Realm Record), <del>_specifier_ (a String)</del><ins>_moduleRequest_ (a ModuleRequest Record)</ins>, _payload_ (a GraphLoadingState Record or a PromiseCapability Record), and _result_ (either a normal completion containing a Module Record or a throw completion) and returns ~unused~.</p>

        <emu-alg>
          1. If _result_ is a normal completion, then
            1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _moduleRequest_.[[Specifier]] <ins>and _record_.[[Type]] is _moduleRequest_.[[Type]]</ins>, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, add Record { [[Specifier]]: _moduleRequest_.[[Specifier]], <ins>[[Type]]: _moduleRequest_.[[Type]]</ins>, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
          1. If _payload_ is a GraphLoadingState Record, then
            1. Perform ContinueModuleLoading(_payload_, _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
          1. Return ~unused~.
        </emu-alg>

        <emu-note type="editor">
          <p>The description of the [[LoadedModules]] field of Realm Record, Script Record, and Cyclic Module Record should be updated to include the [[Type]] field.</p>
        </emu-note>
      </emu-clause>

  <emu-clause id="sec-collect-import-attributes" aoid="CollectImportAttributes">
    <h1>Static Semantics: CollectImportAttributes ( _moduleRequest_ )</h1>
    <emu-grammar> AttributeEntries : AttributeEntries `,` AttributeEntry </emu-grammar>
    <emu-alg>
      1. Perform CollectImportAttributes of |AttributeEntries| with parameters &laquo; _moduleRequest_ &raquo;.
      1. Perform CollectImportAttributes of |AttributeEntry| with parameters &laquo; _moduleRequest_ &raquo;.
    </emu-alg>

    <emu-grammar> AttributeEntry : AttributeKey `:` StringLiteral </emu-grammar>
    <emu-alg>
      1. Let _key_ be StringValue of |AttributeKey|.
      1. If _key_ is *"type"*, then
        1. If _moduleRequest_.[[Type]] is not ~empty~, throw a SyntaxError exception.
        1. Set _moduleRequest_.[[Type]] to the StringValue of |StringLiteral|.
      1. TODO: Throw on unknown keys?
    </emu-alg>
  </emu-clause>

      <emu-clause id="sec-modulerequest-record">
        <h1>ModuleRequest Records</h1>

        <p>A <dfn>ModuleRequest Record</dfn> represents the request to import a module with given import attributes. It consists of the following fields:</p>
        <emu-table id="table-modulerequest-fields" caption="ModuleRequest Record fields">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Specifier]]
                </td>
                <td>
                  String
                </td>
                <td>
                  The module specifier
                </td>
              </tr>
              <tr>
                <td>
                  [[Type]]
                </td>
                <td>
                  a String, or ~empty~
                </td>
                <td>
                  The `type` attribute of this import
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <emu-note type=editor>In general, this proposal replaces places where module specifiers are passed around with ModuleRequest Records. For example, several syntax-directed operations, such as ModuleRequests produce Lists of ModuleRequest Records rather than Lists of Strings which are interpreted as module specifiers. Some algorithms like ImportEntries and ImportEntriesForModule pass around ModuleRequest Records rather than Strings, in a way which doesn't require any particular textual change. Additionally, record fields in Cyclic Module Records and Source Text Module Records which contained Lists of Strings are replaced by Lists of ModuleRequest Records, as indicated above.</emu-note>
      </emu-clause>

        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tbody>
              <tr>
                <th>
                  Field Name
                </th>
                <th>
                  Value Type
                </th>
                <th>
                  Meaning
                </th>
              </tr>
              <tr>
                <td>
                  [[Status]]
                </td>
                <td>
                  ~unlinked~ | ~linking~ | ~linked~ | ~evaluating~ | ~evaluated~
                </td>
                <td>
                  Initially ~unlinked~. Transitions to ~linking~, ~linked~, ~evaluating~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle.
                </td>
              </tr>
              <tr>
                <td>
                  [[EvaluationError]]
                </td>
                <td>
                  An abrupt completion | *undefined*
                </td>
                <td>
                  A completion of type ~throw~ representing the exception that occurred during evaluation.  *undefined* if no exception occurred or if [[Status]] is not ~evaluated~.
                </td>
              </tr>
              <tr>
                <td>
                  [[DFSIndex]]
                </td>
                <td>
                  Integer | *undefined*
                </td>
                <td>
                  Auxiliary field used during Link and Evaluate only.
                  If [[Status]] is ~linking~ or ~evaluating~, this nonnegative number records the point at which the module was first visited during the ongoing depth-first traversal of the dependency graph.
                </td>
              </tr>
              <tr>
                <td>
                  [[DFSAncestorIndex]]
                </td>
                <td>
                  Integer | *undefined*
                </td>
                <td>
                  Auxiliary field used during Link and Evaluate only. If [[Status]] is ~linking~ or ~evaluating~, this is either the module's own [[DFSIndex]] or that of an "earlier" module in the same strongly connected component.
                </td>
              </tr>
              <tr>
                <td>
                  [[RequestedModules]]
                </td>
                <td>
                  List of <del>String</del><ins>ModuleRequest Record</ins>
                </td>
                <td>
                  A List of all the |ModuleSpecifier| strings <ins>with the corresponding `type` import attribute</ins> used by the module represented by this record to request the importation of a module. The List is source code occurrence ordered.
                </td>
              </tr>
            </tbody>
          </table>
        </emu-table>

        <p>An <dfn id="importentry-record">ImportEntry Record</dfn> is a Record that digests information about a single declarative import. Each ImportEntry Record has the fields defined in <emu-xref href="#table-39"></emu-xref>:</p>
        <emu-table id="table-39" caption="ImportEntry Record Fields">
          <table>
            <tbody>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[ModuleRequest]]
              </td>
              <td>
                <del>String</del>
                <ins>ModuleRequest Record</ins>
              </td>
              <td>
                <del>String value of the |ModuleSpecifier| of the |ImportDeclaration|.</del>
                <ins>ModuleRequest Record representing the |ModuleSpecifier| and the `type` import attribute of the |ImportDeclaration|.</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[ImportName]]
              </td>
              <td>
                String
              </td>
              <td>
                The name under which the desired binding is exported by the module identified by [[ModuleRequest]]. The value *"\*"* indicates that the import request is for the target module's namespace object.
              </td>
            </tr>
            <tr>
              <td>
                [[LocalName]]
              </td>
              <td>
                String
              </td>
              <td>
                The name that is used to locally access the imported value from within the importing module.
              </td>
            </tr>
            </tbody>
          </table>
        </emu-table>

      <emu-clause id="sec-static-semantics-modulerequests">
        <h1>Static Semantics: ModuleRequests</h1>
        <emu-see-also-para op="ModuleRequests"></emu-see-also-para>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause `;`</emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be StringValue of |FromClause|.</ins>
          1. <ins>Return a ModuleRequest Record { [[Specifer]]: _specifier_, [[Type]]: ~empty~ }.</ins>
        </emu-alg>
        <emu-grammar>ImportDeclaration : `import` ImportClause FromClause AttributesClause `;`</emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be StringValue of |FromClause|.</ins>
          1. <ins>Let _request_ be the ModuleRequest Record { [[Specifer]]: _specifier_, [[Type]]: ~empty~ }.</ins>
          1. <ins>Perform CollectImportAttributes of |AttributesClause| with argument _request_.</ins>
          1. <ins>Return _request_.</ins>
        </emu-alg>
        <emu-grammar>Module : [empty]</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItem</emu-grammar>
        <emu-alg>
          1. Return ModuleRequests of |ModuleItem|.
        </emu-alg>
        <emu-grammar>ModuleItemList : ModuleItemList ModuleItem</emu-grammar>
        <emu-alg>
          1. Let _moduleNames_ be ModuleRequests of |ModuleItemList|.
          1. Let _additionalNames_ be ModuleRequests of |ModuleItem|.
          1. Append to _moduleNames_ each element of _additionalNames_ that is not already an element of _moduleNames_.
          1. Return _moduleNames_.
        </emu-alg>
        <emu-grammar>ModuleItem : StatementListItem</emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause `;`
        </emu-grammar>
        <emu-alg>
          1. <del>Return ModuleRequests of |FromClause|.</del>
          1. <ins>Let _specifier_ be StringValue of |FromClause|.</ins>
          1. <ins>Return the ModuleRequest Record { [[Specifer]]: _specifier_, [[Type]]: ~empty~ }.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration : `export` ExportFromClause FromClause AttributesClause `;`
        </emu-grammar>
        <emu-alg>
          1. <ins>Let _specifier_ be StringValue of the |StringLiteral| contained in |FromClause|.</ins>
          1. <ins>Let _request_ be the ModuleRequest Record { [[Specifer]]: _specifier_, [[Type]]: ~empty~ }.</ins>
          1. <ins>Perform CollectImportAttributes of |AttributesClause| with argument _request_.</ins>
          1. <ins>Return _request_.</ins>
        </emu-alg>
        <emu-grammar>
          ExportDeclaration :
            `export` NamedExports `;`
            `export` VariableStatement
            `export` Declaration
            `export` `default` HoistableDeclaration
            `export` `default` ClassDeclaration
            `export` `default` AssignmentExpression `;`
        </emu-grammar>
        <emu-alg>
          1. Return a new empty List.
        </emu-alg>
      </emu-clause>
</emu-clause>

<emu-annex id="sec-host-integration">
  <h1>Sample host integration: The Web embedding</h1>

  <p>The import attributes proposal is intended to give key information about how modules are interpreted to hosts. For the Web embedding and environments which aim to be similar to it, the string is interpreted as the "module type". This is not the primary way the module type is determined (which, on the Web, would be the MIME type, and in other environments may be the file extension), but rather a secondary check which is required to pass for the module graph to load.</p>

  <p>In the Web embedding, the following changes would be made to the HTML specification for import attributes:</p>

  <ul>
    <li>The <a href="https://html.spec.whatwg.org/#module-script">module script</a> would have an additional item, which would be the module type, as a string (e.g., *"json"*), or *undefined* for a JavaScript module.</li>
    <li>HostLoadImportedModule would take a ModuleRequest Record parameter in place of a specifier string, which would be passed down through several abstract operations to reach the <a href="https://html.spec.whatwg.org/#fetch-a-single-module-script">fetch a single module script</a> algorithm. Somewhere near the entrypoint, if the ModuleRequest Record's [[Type]] field has an element _entry_ such that _entry_.[[Key]] is *"type"*, then let _type_ be _entry_.[[Value]]; otherwise let _type_ be *undefined*. If the type is invalid, then an exception is thrown and module loading fails. Otherwise, this will equal the module type, if the module can be successfully fetched with a matching MIME type.</li>
    <li>In the <a href="https://html.spec.whatwg.org/#fetch-the-descendants-of-a-module-script">fetch the descendents of a module script</a> algorithm, when iterating over [[RequestedModules]], the elements are ModuleRequest Records rather than just specifier strings; these Records is passed on to the internal module script graph fetching procedure (which sends it to "fetch a single module script". Other usage sites of [[RequestedModules]] ignore the assertion.</li>
    <li>"Fetch a single module script" would check the assertion in two places:
      <ul>
        <li>The module map is keyed with both the absolute URL and the module type, so an existing entry will be found only if its _type_ matches.</li>
        <li>When a new module is fetched, before writing it into the module map, the MIME type is checked to ensure that it matches _type_. (Note that the interpretation of the module is still driven by the MIME type, but once the MIME type is established, this is checked against the _type_.) If they differ, then an exception is thrown and module loading fails. The _type_ is written into the module script as the type.</li>
      </ul>
    </li>
  </ul>

  <p>The module map is keyed by the absolute URL and the _type_. Initially no other import attributes are supported, so they are not present.</p>
</emu-annex>
